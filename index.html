<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <title>Frencil's Corner</title>
</head>

<style>
html {
  background: url(Embers.jpg) no-repeat center center fixed;
  -webkit-background-size: cover;
  -moz-background-size: cover;
  -o-background-size: cover;
  background-size: cover;
  font-family: Helvetica, Arial, sans-serif;
  color: rgb(237, 251, 255);
}
.column {
  background-color: rgb(34, 37, 38);
  width: 800px;
  position: absolute;
  top: 0px;
  left: 40px;
  padding: 40px;
}
hr {
  width: 100%;
  margin-top: 20px;
  margin-bottom: 20px;
}
h1 {
  margin-bottom: 10px;
}
.subtitle {
  color: rgba(237, 251, 255, 0.5);
  font-style: italic;
  font-weight:bold;
  font-size: 80%;
}
p ul li {
  color: rgba(237, 251, 255, 0.8);
}
a {
  color: rgb(151, 189, 199);
}
a:visited {
  color: rgb(114, 146, 156);
}
.date {
  color: rgba(237, 251, 255, 0.5);
  font-weight:bold;
  font-size: 80%;
  margin-left: 10px;
}

</style>

<body>

<div class="column">
  <h1>Frencil's Corner</h1>
  <div class="subtitle">Frencil is Christopher Clark, a guy who likes science, math, and programming.</div>
  <hr>

  <!-- 2014-11-12 -->
  <a name="2014-11-12"></a>
  <h2>An Initial Look at Cesium <span class="date">2014-12-01</span></h2>
  <p>I spent some of last night playing with <a href="http://cesiumjs.org/">Cesium</a>. In a nutshell it's a web-based open-source Google Earth (though I'm sure the developers prefer that Google Earth be known as the proprietary client-installed Cesium). More clearly, it's a JavaScript WebGL platform for creating an interactive model of the planet Earth. And it's cool.</p>
  <p>My first challenge was getting WebGL running. <a href="http://get.webgl.org/">WebGL</a> is a fairly new thing and so the open source ATI Drivers for Linux don't support it. In typical Linux fashion, installing the proprietary drivers did <i>not</i> happen cleanly. Immediately after installation the default theme for Mint 16 broke in a variety of ways. Attempting to troubleshoot the problem led me to the dreaded partial dist-upgrade. For a while there I was a thousand miles from home (at the in-laws' for Thnksgiving) and my travel laptop wouldn't even boot to a command prompt. Next time I travel I'm bringing an emergency USB bootable distro of some kind.</p>
  <p>It turned out that my x server was locking up and crashing becuase of some deep incompatibility between the still installed proprietary graphics drivers and the partially upgraded OS. Once I found my way back to a command line I went full upgrade to Mint 17, blasted and reinstalled the ATI drivers, and got everything working again.</p>
  <p align="center">***</p>
  <p>Cesium has clearly been built with developers in mind. This is evidenced, first off, by the extensive documentation and starter tutorials that come packaged in the build. Fairly sure what I wanted to build but unsure of how best to deploy it I started by forking the <a href="https://github.com/AnalyticalGraphicsInc/cesium">main repository</a> and following the <a href="https://github.com/AnalyticalGraphicsInc/cesium/wiki/Contributor%27s-Guide">Contributor's Guide</a> in the wiki.</p>
  <p>The build has a lot in it, though, and it's not immediately clear how best to deploy a minimal setup for a standalone project. Take for example the Sandcastle - the included tutorial system. You're presented with a split window that has a JavaScript emulating console on the left, a WebGL display running the Cesium "final product" on the right (the interactive Earth model) and a carousel of example tutorials along the bottom. If nothing else I found this most helpful as a collection of code snippets with quick visual access to what they do - something that greatly facilitated learning the API conventions. The documentation, while extensive, requires a solid understanding of the object-oriented architecture of the platform. Seeing archetypal snippets in action helped primarily to expose the building blocks of the archetecture, but there's still a lot to learn.</p>
  <p>At any rate, when my project is ready to go I'll want to deploy it with a minimal footprint, so understanding the structure of the build will be important. A production Cesium app won't need the tutorials, the documentation, or the Sandbox with all its extras like hooks for capturing clicks in the model to highlight lines of JavaScript in the console. But first things first: a working app with a purpose.</p>
  <p align="center">***</p>
  <p>On August 21, 2017 there will be a total solar eclipse that cuts directly across North America. My excitement for this simply can't be understated. When I was in elementary school the first partial solar eclipse in my region of the world happened and I saw my first crescent sun. Countless lunar eclipses later we were treated to another partial solar eclipse <a href="https://twitter.com/Frencil/status/525414443837325314">just this past October</a>, so I built a solar filter for my telescope. But I've never seen a total solar eclipse, never observed the sun's corona with my own (protected) eyes.</p>
  <p>Eclipses are strange beasts to conceptualize on their full four-dimensional scale. It's a shadow that streaks across the surface of the Earth in a slow, undulating arc. For this eclipse in partiular the swath is wide and stretches from Washington state to South Carolina. I'll be camping, somehwere, but <i>where</i>? There's so much excellent wilderness along the track, and while there are <a href="http://www.greatamericaneclipse.com/">abundant maps</a> available they are all static images with static scale. Cesium, however, is interactive - zoomable, panable, and able to import satellite imagery, road maps, and so much other public data. It's a giant dynamic map. All it needs are details of the event.</p>
  <p>Using some <a href="http://eclipse.gsfc.nasa.gov/SEpath/SEpath2001/SE2017Aug21Tpath.html">coarse NASA waypoint data</a> for the northern/southern limits and central line of the eclipse track I was able to produce this:</p>
  <center><a href="img/cesium_eclipse_track.jpg"><img src="img/cesium_eclipse_track.jpg"></a></center>
  <p>The most satisfying moment, of course, was going from a proof-of-concept for polyline rendering (three points) to the full data set. There was the swath I'd seen in so many static images, landing right where I expected it to be, and now I could navigate along the track at almost any scale I wanted!</p>
  <p>The app still needs a <i>lot</i> of work, and it's not deployed anywhere just yet. I suppose I have until the summer of 2017, but it should be up in the next few months all the same. I next plan to convert the main polylines into a more portable and organized <a href="https://github.com/AnalyticalGraphicsInc/cesium/wiki/CZML-Guide">CZML</a> document, then begin learning how animations in Cesium work. Cesium has a timeline feature that's quite easy to use, so it was trivial to loop the virtual clock over the time frame of the eclipse on that future August afternoon. The minimum viable product, therefore, is a traveling shadow so any user could dial in their time to see exactly where the moon's shadow falls at any time to any level of detail. Now <i>that's</i> something I want to play with.</p>

  <br><hr><br>
  
  <!-- 2014-11-12 -->
  <a name="2014-11-12"></a>
  <h2>When another you creates branches <span class="date">2014-11-12</span></h2>
  <p>I picked up the nuclides project on my laptop tonight, only to find that the version on there was far more complete than what I'd been working on - something I didn't remember doing.</p>
  <p>It turns out earlier this year I must have copied just the data files manually from the <a href="https://github.com/Frencil/galaxy_of_nuclides">public repository</a> and started a fresh build of an interface to that data. In my last post I talked about getting something going on <a href="http://www.createjs.com/#!/CreateJS">Create.js</a> but at the time I didn't remember just how far I'd gotten. It turns out, <a href="http://nuclides.org/v2/">kinda far</a>. Surprising how one can forget entire episodes of projects.</p>
  <p>There was no <tt>.git</tt> directory in the local copy built this way, which is baffling. That wrong has been corrected with the <a href="https://github.com/Frencil/galaxy_of_nuclides/tree/canvas">canvas</a> branch on the public repo (but for now lets call it <b>version 2</b>, as if <b>version 1</b> was the original program in Processing). While it looks neat it is a dead end branch, as I'll describe below, but at least now it's preserved. If that link ever needs to come down for whatever reason here's what it looks like:</p>
  <center><a href="img/nuclides_v2_full.jpg"><img src="img/nuclides_v2_med.jpg"></a></center>
  <p>As of this writing, the current D3 version (which would be <b>version 3</b>) deployed to <a href="http://nuclides.org">nuclides.org</a> is <i>way</i> less visually advanced. Version 2 has a functional transition between the periodic table and chart of nuclides as well as a meaningful color scale and carefully designed control buttons. So why walk away from it?</p>
  <p>Why I put it down is also why I so named the archival branch: <b>canvas</b>. This project is an entirely graphical interface so the choice of rendering environment is critical, and this version uses the HTML5 <tt>&lt;canvas&gt;</tt> element. Things were fast to spin up because I could just draw and figure out the structure as I went. Elements would appear with a z-index relative to when I rendered them, which was easy enough to grasp.</p>
  <p>But there were limitations that started to pile up. Everything was rendered in a rolled up function that would need to fire in full on every action: mouseover events, transitions scheduled with an arbitrary refresh rate via <tt>setTimeout()</tt>, and any future animations. Those mouseover events? Forget mouse input from the DOM. I had to reinvent that wheel myself by way of invisible rectangles and generic hit test functions. Need to remove a single graphical element from the view? Track visibility states on every element for when the render function redraws everything from blank canvas. Pray that redraw stays fast enough for users on underpowered machines as it grows in complexity. And now I remember: I abandoned this version precisely when realizing how tough it would be to build a basic slider for playing with half life data.</p>
  <p>So how has D3 and SVG held up by comparison? For starters, D3 took a fair bit longer to produce <i>any</i> visual result. Knowing the right way to do it would be to use selectors with the <tt>enter()</tt> method to dynamically generate SVG objects directly from the data set meant skipping the "Hello world" step of just drawing a rectangle. It was a slog of adapting documentation and examples to my unique dataset until it just worked but looked crummy. As I've worked with it, though, and developed a feel for how it organizes itself under the hood, it feels like the opposite is coming true: instead of an initially fast dev process that grinds down it's an initially slow dev process that affords faster development as I go. A big part of this was being forced to structure my data and my display as a unified chunk of nested markup. A bonus to doing this, and how SVG works, is I can explore my entire display down to individual graphical elements through the DOM inspector (where this was <i>totally</i> opaque inside the <tt>&lt;canvas&gt;</tt> element). That alone promises to expedite all future debugging and development by several orders of magnitude!</p>
  <p>So while it was neat to discover a branch I'd totally forgotten about (and be surprised by how far it went) it's helped bolster confidence that the new approach is the right one. Or, at least, a better one. Hopefully there won't need to be a <b>version 4</b>.</p>

  <br><hr><br>

  <!-- 2014-11-09 -->
  <a name="2014-11-09"></a>
  <h2>Getting back into D3 <span class="date">2014-11-09</span></h2>
  <p>I spent most of the weekend dusting off an <a href="https://github.com/Frencil/galaxy_of_nuclides">old project</a>. The point of the project is mainly to play around with all the neat data surrounding elements and their nuclides. Maybe it'll also be a useful tool for teaching folks a bit more about atomic physics, too.</p>
  <p>A big part of the project was just <i>getting</i> the data in the first place, which I was able to get from the Brookhaven National Laboratory, but it needed a bit of massaging. Ultimately I created two CSV files: <a href="https://github.com/Frencil/galaxy_of_nuclides/blob/master/data/elements.csv">one for all elements on the periodic table of elements</a> and <a href="https://github.com/Frencil/galaxy_of_nuclides/blob/master/data/nuclides.csv">one for all nuclides on the chart of nuclides</a>.</p>
  <p>When I set out to port the two year old project from its original language of Processing to the web it was obvious that it needed to be built natively in JavaScript (yeah, I tried Processing.js but I was using some Java datatypes that Processing.js didn't support and the whole thing was a crutch anyway). Unsurprisingly I found a lot of different JavaScript libraries out there for doing interactive graphics, but it wasn't clear which one to use. I had something going for a while with <a href="http://www.createjs.com/#!/CreateJS">Create.js</a> but found I still needed a lot of helper libraries too, like jQuery and its associated CSV parsing lib. The project felt bloated before I even had any data parsed. It stalled and went back on the shelf.</p>
  <p>On coming back to the nuclides project with fresh vigor and perspective I remembered the gold standard: <b>D3</b>. I used D3 at SparkFun to build force-directed graph to display our company org chart. That was my first real look at the software, and it was adapted from an example I found online. The example was close enought to my use case - a means of representing relationships between people - that adaptation didn't require an intimate understanding of how everything was put together.</p>
  <p>Understanding that D3 would ultimately give the nuclides project the low-level control and flexibility I knew I would probably need in the long run I started from scratch, learning how to parse data and bind it to objects with selectors. Fortunately from another SparkFun project creating a detailed SVG map of the corporate headquarters and some side business helping patch a bug in a library I found for panning and zooming embedded SVGs I had some good SVG experience that was fresh in mind.</p>
  <p>The toughest part starting a D3 project with highly structured but complex data, as I found, is the lack of firm knowledge of what the visualization should look like. I know I want to represent my data as the periodic table and as the chart of nuclides. I know I'll want to interactively transition between them to show how they connect, as it's worked in the Processing version for years. Approaching the layout of the SVG itself has been very much trial and error thus far. At first I was just appending <tt>&lt;rect&gt;</tt> objects to the <tt>&lt;svg&gt;</tt> but quickly learned that <tt>&lt;text&gt;</tt> can't be a child of a <tt>&lt;rect&gt;</tt> such that it would show up how you would expect. If I wanted to associate elements it meant <tt>&lt;g&gt;</tt> tags. Lots and lots of <tt>&lt;g&gt;</tt> tags.</p>
  <p>At this weekend's stopping point here's a general summary of how I've chosen to structure the <tt>&lt;svg&gt;</tt>:</p>
  <ul>
    <li>All data is loaded through D3's built-in functions.</li>
    <li>All svg elements are created relying as much as possible on the conventions defined in D3's API (e.g. using <tt>.each()</tt> instead of <tt>foreach</tt> loops).</li>
    <li>All top-level elements in the <tt>&lt;svg&gt;</tt> are <tt>&lt;g&gt;</tt> tags, and there aren't many of them at the top level, so I can easily nuke and redraw the entire thing (for easier dynamic resizing).</li>
    <li>I have three general classes of <tt>&lt;g&gt;</tt> objects:
      <ul>
        <li><tt>group</tt> is for a <tt>&lt;g&gt;</tt> that contains a list of other <tt>&lt;g&gt;</tt> tags (e.g. all of the elements or all the nuclides for an element).</li>
        <li><tt>shell</tt> is for a <tt>&lt;g&gt;</tt> that represents a single object from the data set and all of its constituent pieces, be they shown or not (e.g. a single element or nuclide).</li>
        <li><tt>display</tt> is for all the <tt>&lt;rect&gt;</tt>, <tt>&lt;text&gt;</tt>, and whatever else is used to actually display a thing.</li>
      </ul>
    </li>
    <li>The general classes of <tt>&lt;g&gt;</tt> tags are used to aid selection of collections of elements that need to move and change together.</li>
    <li><tt>&lt;g&gt;</tt> tags are positioned using dynamically generated <tt>translate()</tt> functions with <tt>transform</tt> attributes. This allows for positioning elements inside groups using relative coordinates and dramatically cuts down on coordinate translation overhead that I have to code myself.</li>
  </ul>
  <p>Given the above I've ended up with an <tt>&lt;svg&gt;</tt> that looks something like this:</p>
  <pre>
&lt;svg&gt;
  &lt;g class="element_group"&gt;
    &lt;g class="element_shell"&gt;
      &lt;g class="element_display"&gt;
        &lt;rect&gt;
        &lt;text&gt;
      &lt;/g&gt;
      &lt;g class="nuclide_group"&gt;
        &lt;g class="nuclide_shell"&gt;
          &lt;g class="nuclide_display"&gt;
            &lt;rect&gt;
          &lt;/g&gt;
        &lt;/g&gt;
        ...
      &lt;/g&gt;
    &lt;/g&gt;
    ...
  &lt;/g&gt;
&lt;/svg&gt;
  </pre>
  <p>I've had this setup for a day and I like it. The next hurdle is to really leverage transitions to make the periodic-table-to-chart-of-nuclides animation (and it's reverse) look as neat as it does in my head. I hope I can get it working cleanly without having to rethink all this scaffolding.

  <br><hr><br>
  
  <!-- 2014-10-30 -->
  <a name="2014-10-30"></a>
  <h2>Initializing Frencil's Corner <span class="date">2014-10-30</span></h2>
  <p>My good friend <a href="http://squiggle.city/~brennen/">Brennen</a> set up this server - squiggle.city - modelled after tilde.club. Naturally I asked for an account immediately.</p>
  <p>Given the state of the various projects I have going right now, and in anticipation of life upheaval in the coming year, it seemed as good a place as any to start a little blog that nobody reads. I maintain the best blogs on the internet are ones with incredibly low readership because readership isn't a priority over just documenting thoughts and ideas. That's what this will be.</p>
  <p>Going forward this will probably mutate some but right now it appears this will be a place to ruminate on the twists and turns my personal projects take. Be they coding projects, photography / time lapse projects, astronomy projects, or whatever else, I'll spare some bit of creative energy to document what I'm thinking here. This is mainly an exercise for my future self to know a bit more about my past self, but if you've stumbled uppon this, I hope you've found something enjoyable.</p>

  <br><hr><br>
  
</div>

</body>
</html>
